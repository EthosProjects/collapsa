<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Source: index.js</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Source: index.js</h1>

    



    
    <section>
        <article>
            <pre class="prettyprint source linenums"><code>'use strict';
var rp = require('request-promise');
const https = require('https')
const { EventEmitter } = require('events')
const database = require('./database')
const collection = require('./collection')
const document = require('./document')
Map = require('discord.js').Collection
const getAllData = res => {
    return new Promise((resolve, reject) => {
        let buffer = []
        res.on('data', data => buffer.push(data))
        res.on('end', () => resolve(JSON.parse(buffer.join(''))))
    })
}
const getBrokenData = res => {
    return new Promise((resolve, reject) => {
        let buffer = []
        res.on('data', data => buffer.push(data))
        res.on('end', () => resolve(buffer.join('')))
    })
}
module.exports = class mlabInteractor extends EventEmitter {
    /**
     * @param {string} apiKey 
     * @param {Array.&lt;String>} ignore
     */
    constructor(apiKey, ignore = []){
        super()
        this.apiKey = apiKey;
        /**
         * @type {Map&lt;string, database>}
         */
        this.databases = new Map()
        https.request({
            host:'api.mongolab.com',
            path:`/api/1/databases?apiKey=${apiKey}`,
            method:"GET"
        })
        .on('response', async res => {
            if(res.statusCode >= 400) return this.emit('error', JSON.parse(await getBrokenData(res)).message)
            let data = await getAllData(res)
            data = data.filter(d => !ignore.includes(d))
            let dataPromise = data.map(async databaseName => {
                return new Promise(resolve => {
                    https.get(`https://api.mongolab.com/api/1/databases/${databaseName}/collections?apiKey=${apiKey}`)
                    .on('response', async res => {
                        if(res.statusCode >= 400) return this.emit('error', JSON.parse(await getBrokenData(res)).message)
                        let data = await getAllData(res)
                        let skip = ['objectlabs-system', 'objectlabs-system.admin.collections', 'system.indexes']
                        data = data.filter(d => !skip.includes(d))
                        /**
                         * @type {Array.&lt;Promise&lt;collection>>}
                         */
                        let dataPromise = data.map(async collectionName => {
                            return new Promise(resolve => {
                                https.get(`https://api.mongolab.com/api/1/databases/${databaseName}/collections/${collectionName}?apiKey=${apiKey}`)
                                .on('response', async res => {
                                    if(res.statusCode >= 400) return this.emit('error', JSON.parse(await getBrokenData(res)).message)
                                    let data = await getAllData(res)
                                    resolve(new collection(apiKey, collectionName, data.map(d => [d.id ? d.id : d._id.$oid, new document(apiKey, d.id ? d.id : d._id.$oid, d)]), databaseName))
                                })
                            })
                        })
                        Promise.all(dataPromise)
                            .then(c => {
                                resolve(data.map((d, i) => [d, c[i]]))
                            })
                    })
                })
            })
            Promise.all(dataPromise)
                .then(d => {
                    d.forEach((d, i) => {
                        this.databases.set(data[i], new database(apiKey, data[i], d))
                    })
                    this.emit('ready')
                })
        })
        .end()
        rp({
            uri:`https://api.mongolab.com/api/1/databases?`,
            qs:{
                apiKey:this.apiKey
            }
        })
            .then(res => {
                if(res.message == 'Please provide a valid API key.')
                throw new Error('Invalid API key')
            });
    }
    listDatabases(){
        var opt = {
            uri: 'https://api.mongolab.com/api/1/databases',
            qs: {
                apiKey:this.apiKey // -> uri + '?access_token=xxxxx%20xxxxx'
            },
            headers: {
                'User-Agent': 'Request-Promise'
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }
    listCollections(db){
        if(!db || typeof db != 'string') throw new Error('Invalid Database name')
        var opt = {
            uri: `https://api.mongolab.com/api/1/databases/${db}/collections`,
            qs: {
                apiKey:this.apiKey // -> uri + '?access_token=xxxxx%20xxxxx'
            },
            headers: {
                'User-Agent': 'Request-Promise'
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }
    listDocuments(options){
        if(!options.database || !options.collectionName) throw new Error('Database Name and Collection Name are required')
        var op = {
            q: options.query,
            c: options.resultCount,
            f: options.setOfFields,
            fo: options.findOne,
            s: options.sortOrder,
            sk: options.skipResults,
            l: options.limit
        };
        var opt = {
            uri: `https://api.mongolab.com/api/1/databases/${options.database}/collections/${options.collectionName}`,
            headers: {
                'User-Agent': 'Request-Promise'
            },
            qs:{
                apiKey:this.apiKey,
                q:op.q,
                c:op.c,
                f:op.f,
                fo:op.fo,
                s: op.s,
                sk:op.sk,
                l:op.l
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }   
    insertDocuments(options){
        if(!options.database || !options.collectionName || ! options.documents) throw new Error('Invalid options')
        var opt = {
            uri: `https://api.mongolab.com/api/1/databases/${options.database}/collections/${options.collectionName}`,
            qs: {
                apiKey:this.apiKey 
              
            },
            method:'POST',
            body: options.documents,
            headers: {
                'User-Agent': 'Request-Promise'
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }
    updateDocuments(options){
        if(!options.database || !options.collectionName || !options.documents) throw new Error('Invalid Options')
        var op = {
            q: options.query,
            m: options.allDocuments,
            u: options.upsert
        };
        var opt = {
            uri: `https://api.mongolab.com/api/1/databases/${options.database}/collections/${options.collectionName}?apiKey=${this.apiKey}`,
            qs: {
                apiKey:this.apiKey,
                q:op.q,
                m:op.m,
                u:op.u
            },
            method:'PUT',
            body: {
                "$set":options.data
            },
            headers: {
                'User-Agent': 'Request-Promise'
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }
    deleteDocuments(options){
        if(!options.database || !options.collectionName) throw new Error('Invalid Options')
        if(!options.documents) options.documents = []
        var op = {
            q:options.query
        }
        var opt = {
            uri: `https://api.mongolab.com/api/1/databases/${options.database}/collections/${options.collectionName}`,
            qs: {
                apiKey:this.apiKey,
                q:op.q
              
            },
            method:'PUT',
            body: options.documents,
            headers: {
                'User-Agent': 'Request-Promise'
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }
    viewDocument(options){
        if(!options.database || !options.collectionName || !options.id) throw new Error('Invalid Options')
        var opt = {
            uri: `https://api.mongolab.com/api/1/databases/${options.database}/collections/${options.collectionName}/${options.id}`,
            qs: {
                apiKey:this.apiKey // -> uri + '?access_token=xxxxx%20xxxxx'
            },
            headers: {
                'User-Agent': 'Request-Promise'
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }
    updateDocument(options){
        if(!options.database || !options.collectionName || !options.id || !options.updateObject) throw new Error('Invalid Options')
        var opt = {
            uri: `https://api.mongolab.com/api/1/databases/${options.database}/collections/${options.collectionName}/${options.id}`,
            method:'PUT',
            body:options.updateObject,
            qs: {
                apiKey:this.apiKey // -> uri + '?access_token=xxxxx%20xxxxx'
            },
            headers: {
                'User-Agent': 'Request-Promise'
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }
    deleteDocument(options){
        if(!options.database || !options.collectionName || !options.id) throw new Error('Invalid Options')
        var opt = {
            uri: `https://api.mongolab.com/api/1/databases/${options.database}/collections/${options.collectionName}/${options.id}`,
            method:'DELETE',
            qs: {
                apiKey:this.apiKey // -> uri + '?access_token=xxxxx%20xxxxx'
            },
            headers: {
                'User-Agent': 'Request-Promise'
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }
    runCommand(options){
        if(!options.database || !options.commands) throw new Error('Invalid Options')
        var opt = {
            uri: `https://api.mongolab.com/api/1/databases/${options.database}/runCommand`,
            method:'POST',
            body:options.commands,
            qs: {
                apiKey:this.apiKey // -> uri + '?access_token=xxxxx%20xxxxx'
            },
            headers: {
                'User-Agent': 'Request-Promise'
            },
            json: true // Automatically parses the JSON string in the response
        };
        return rp(opt)
    }
}</code></pre>
        </article>
    </section>




</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="module.exports_module.exports.html">exports</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 3.6.4</a> on Tue Jun 02 2020 22:01:59 GMT-0400 (Eastern Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>
