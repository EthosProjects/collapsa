 <head>
  <style>
    body {
        width:100%;
        height:100%;
        margin:0
    }
    #ctx {
        width:300px;
        height:300px;
        border:1px solid black;
    }
    #video {
        border:1px solid black;
        width:40%;
        height:40%;
        display:none;
    }
  </style>
</head>
<body>
        <canvas id="ctx"></canvas>
    <video autoplay id="video"></video>
<script>
    let pixel = '1080px'
    let pixelNum = parseInt(pixel)
    console.log(pixelNum)
    let ctx = document.getElementById('ctx').getContext('2d')
    /** 
    * @type {HTMLCanvasElement}
    */
    let canvas = document.getElementById('ctx')
    canvas.style.width = pixelNum + 'px'
    canvas.style.height = pixelNum + 'px'
    canvas.width = parseInt(pixel)
    canvas.height = parseInt(pixel)
    let Img = {
        
    }
    
    let createImage = (src, extention) => {
        Img[`${src}`] = new Image()
        Img[`${src}`].src = `/client/img/${src}.${extention}`
    }
    createImage('stonesword', 'png')
    
    createImage('stoneaxe', 'png')
  
    createImage('stonepickaxe', 'png')
  
    createImage('stonehammer', 'png')
    let firstColor = '#CECECE'
    let secondColor = '#bababa'
    let thirdColor = '#999999'
    let fourthColor = 'grey'
    let drawFourWay = (x, y) => {
        ctx.save()
        ctx.translate(x, y)
        ctx.fillStyle = firstColor
        ctx.fillRect(0, 0, 150, 150)
        ctx.fillStyle = secondColor
        ctx.fillRect(10, 0, 130, 150)
        ctx.fillStyle = secondColor
        ctx.fillRect(0, 10, 150, 130)
        ctx.fillStyle = thirdColor
        ctx.fillRect(30, 0, 90, 150)
        ctx.fillStyle = thirdColor
        ctx.fillRect(0, 30, 150, 90)
        ctx.fillStyle = fourthColor
        ctx.fillRect(50, 0, 50, 150)
        ctx.fillStyle = fourthColor
        ctx.fillRect(0, 50, 150, 50)
        ctx.restore()
    }
    let drawThreeWay = (x, y) => {
        ctx.save()
        ctx.translate(x, y)
        ctx.fillStyle = firstColor
        ctx.fillRect(0, 0, 150, 150)
        ctx.fillStyle = secondColor
        ctx.fillRect(10, 10, 130, 140)
        ctx.fillStyle = secondColor
        ctx.fillRect(0, 10, 150, 130)
        ctx.fillStyle = thirdColor
        ctx.fillRect(30, 30, 90, 120)
        ctx.fillStyle = thirdColor
        ctx.fillRect(0, 30, 150, 90)
        ctx.fillStyle = fourthColor
        ctx.fillRect(50, 50, 50, 100)
        ctx.fillStyle = fourthColor
        ctx.fillRect(0, 50, 150, 50)
        ctx.restore()
    }
    let drawTwoWay = (x, y) => {
        ctx.fillStyle = firstColor
        ctx.fillRect(0, 0, 150, 150)
        ctx.fillStyle = secondColor
        ctx.fillRect(0, 10, 150, 130)
        ctx.fillStyle = thirdColor
        ctx.fillRect(0, 30, 150, 90)
        ctx.fillStyle = fourthColor
        ctx.fillRect(0, 50, 150, 50)
    }
    let drawCorner = (x, y) => {
        ctx.save()
        ctx.translate(x, y)
        ctx.fillStyle = firstColor
        ctx.fillRect(0, 0, 150, 150)
        ctx.fillStyle = secondColor
        ctx.fillRect(10, 10, 130, 140)
        ctx.fillStyle = secondColor
        ctx.fillRect(10, 10, 140, 130)
        ctx.fillStyle = thirdColor
        ctx.fillRect(30, 30, 90, 120)
        ctx.fillStyle = thirdColor
        ctx.fillRect(30, 30, 120, 90)
        ctx.fillStyle = fourthColor
        ctx.fillRect(50, 50, 50, 100)
        ctx.fillStyle = fourthColor
        ctx.fillRect(50, 50, 100, 50)
        ctx.restore()
    }
    let drawOneWay = (x, y) => {
        ctx.save()
        ctx.translate(x, y)
        ctx.fillStyle = firstColor
        ctx.fillRect(0, 0, 150, 150)
        ctx.fillStyle = secondColor
        ctx.fillRect(10, 10, 140, 130)
        ctx.fillStyle = thirdColor
        ctx.fillRect(30, 30, 120, 90)
        ctx.fillStyle = fourthColor
        ctx.fillRect(50, 50, 100, 50)
    }
    
    let drawWall = (x, y) => {
        ctx.save()
        ctx.translate(x, y)
        ctx.fillStyle = firstColor
        ctx.fillRect(0, 0, 150, 150)
        ctx.fillStyle = secondColor
        ctx.fillRect(10, 10, 130, 130)
        ctx.fillStyle = thirdColor
        ctx.fillRect(30, 30, 90, 90)
        ctx.fillStyle = fourthColor
        ctx.fillRect(50, 50, 50, 50)
    }
    let drawCraftingTable = (x, y) => {
        ctx.save()
        ctx.translate(x, y)
        ctx.fillStyle = '#808080'
        ctx.fillRect(0, 0 , 200, 200)
        ctx.fillStyle = '#4E2D05'
        ctx.fillRect(10, 10 , 180, 180)
        ctx.fillStyle = '#8D5010'
        ctx.fillRect(10, 100 - 8.5 , 180, 17)
        ctx.fillRect(100 - 8.5, 10 , 17, 180)
        ctx.save()
        ctx.translate(10 + 35, 10 + 35)
        ctx.rotate(45 * Math.PI / 180)
        ctx.drawImage(Img.stonesword, -25, -35, 70, 70)
        ctx.restore()
        ctx.save()
        ctx.translate(110 + 35, 10 + 35)
        ctx.rotate(45 * Math.PI / 180)
        ctx.drawImage(Img.stoneaxe, -30, -30, 70, 70)
        ctx.restore()
        ctx.save()
        ctx.translate(10 + 35, 110 + 35)
        ctx.rotate(45 * Math.PI / 180)
        ctx.drawImage(Img.stonepickaxe, -30, -30, 70, 70)
        ctx.restore()
        ctx.save()
        ctx.translate(110 + 35, 110 + 35)
        ctx.rotate(45 * Math.PI / 180)
        ctx.drawImage(Img.stonehammer, -30, -30, 70, 70)
        ctx.restore()
        ctx.restore()
    }
    let c = {
        x:50,
        y:50
    }
    class miniPlayer {
        constructor(initPack){
            this.usr = initPack.usr || ''
            this.x = initPack.x
            this.y = initPack.y
            this.hp = initPack.health || 20
            this.maxHp = initPack.maxHp || 20
            this.food = initPack.food || 20 
            this.maxFood = initPack.maxFood || 20
            this.mainHand = initPack.mainHand || 'hand'
            this.id = initPack.id || Math.random()
            this.angle = initPack.angle || 0
            this.lhit = initPack.lhit || false
            this.rhit = initPack.rhit || false
            this.rad = initPack.rad || 28
            this.msg = []
            this.clan = initPack.clan || null
        }
        drawPerf(opt){
            if(!opt) opt = {}
            ctx.restore()
            ctx.save()
            ctx.scale(this.rad/25, this.rad/25)
            var currx = (this.x)/(this.rad/25)
            var curry = (this.y)/(this.rad/25)
            if(currx < -this.rad || currx > canvas.width + this.rad) return
            if(curry < -this.rad || curry > canvas.height + this.rad) return
            ctx.save();
            
            //ctx.drawImage(Img.player, currx - this.rad, curry - this.rad, this.rad * 2, this.rad * 2)
            
            ctx.save()
            ctx.beginPath()
            ctx.fillStyle = 'red';
            if(opt.drawHp) var hpBar = 80 * this.rad/25 * this.hp / this.maxHp
            ctx.fillRect(currx - 40 * this.rad/25 , curry - 50 * this.rad/25, hpBar, 10);
            ctx.fillStyle = 'blue';
            if(opt.drawStamina) var staminaBar = 80 * this.rad/25 * this.stamina / this.maxStamina
            ctx.fillRect(currx - 40 * this.rad/25, curry - 2 * this.rad + 10, staminaBar, 10　);
            ctx.fillStyle = 'orange'
            if(opt.drawFood) var foodBar = 80 * this.rad/25 * this.food / this.maxFood
            ctx.fillRect(currx - 40 * this.rad/25, curry - 50 * this.rad/25 - 10, foodBar, 10　);
            if(this.clan){ 
                ctx.textAlign = "center"
                ctx.font = '18px Zorque';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath()
                ctx.strokeText(`[${this.clan}]${this.usr}`, currx, curry + 55 * this.rad/25); 
                ctx.fillStyle = 'white';
                ctx.fillText(`[${this.clan}]${this.usr}`, currx, curry + 55 * this.rad/25);
            }else {
                ctx.textAlign = "center"
                ctx.font = '18px Zorque';
                ctx.strokeStyle = 'black';
                ctx.lineWidth = 2;
                ctx.beginPath()
                ctx.strokeText(this.usr, currx, curry + 55 * this.rad/25); 
                ctx.fillStyle = 'white';
                ctx.fillText(this.usr, currx, curry + 55 * this.rad/25);
            }
            this.msg.forEach((msgObj, i) => {
                if(this.msg.length == 1 && i == 0){
                    ctx.globalAlpha = Math.abs(msgObj.per - 1)
                    ctx.textAlign = "center"
                    ctx.font = '12px Arial';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath()
                    ctx.strokeText(msgObj.msg, currx, curry - 60 * this.rad/25);
                    ctx.fillStyle = 'white';
                    ctx.fillText(msgObj.msg, currx, curry - 60 * this.rad/25);
                }else if(this.msg.length == 2 && i == 1){
                    ctx.globalAlpha = Math.abs(msgObj.per - 1)
                    ctx.textAlign = "center"
                    ctx.font = '12px Arial';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath()
                    ctx.strokeText(msgObj.msg, currx, curry - 60 * this.rad/25);
                    ctx.fillStyle = 'white';
                    ctx.fillText(msgObj.msg, currx, curry - 60 * this.rad/25);
                }else if(this.msg.length == 2 && i == 0){
                    ctx.globalAlpha = Math.abs(msgObj.per - 1)
                    ctx.textAlign = "center"
                    ctx.font = '12px Arial';
                    ctx.strokeStyle = 'black';
                    ctx.lineWidth = 2;
                    ctx.beginPath()
                    ctx.strokeText(msgObj.msg, currx, curry - 20 - 60 * this.rad/25);
                    ctx.fillStyle = 'white';
                    ctx.fillText(msgObj.msg, currx, curry - 20 - 60 * this.rad/25);
                }
            })
            ctx.globalAlpha = 1
            ctx.translate(currx, curry)
            
            ctx.rotate((Math.PI / 180) * this.angle)
            ctx.scale(this.rad/25, this.rad/25)
            if (this.mainHand == 'hand') {
                if (!(this.rhit)) {
                    ctx.beginPath()
                    ctx.fillStyle = 'black'
                    ctx.arc(32, 15, 7.5, 0, 2 * Math.PI)
                    ctx.fill()
                    ctx.beginPath()
                    ctx.fillStyle = '#7F7F7F'
                    ctx.arc(32, 15, 7.5 - 2, 0, 2 * Math.PI)
                    ctx.fill()
                    //ctx.drawImage(Img.hand, 32 - 7.5, 15 - 7.5, 15, 15)
                } else {
                    ctx.save();
                    ctx.translate(32 - 7.5, 15 - 7.5);
                    ctx.rotate((Math.PI / 180) * (360 - (-Math.abs(-160 * this.punchper + 80) + 80)))
                    ctx.beginPath()
                    ctx.fillStyle = 'black'
                    ctx.arc(7.5, 7.5, 7.5, 0, 2 * Math.PI)
                    ctx.fill()
                    ctx.beginPath()
                    ctx.fillStyle = '#7F7F7F'
                    ctx.arc(7.5, 7.5, 7.5 - 2, 0, 2 * Math.PI)
                    ctx.fill()
                    ctx.restore()
                }
                if (!(this.lhit)) {
                    ctx.beginPath()
                    ctx.fillStyle = 'black'
                    ctx.arc(32, -15, 7.5, 0, 2 * Math.PI)
                    ctx.fill()
                    ctx.beginPath()
                    ctx.fillStyle = '#7F7F7F'
                    ctx.arc(32, -15, 7.5 - 2, 0, 2 * Math.PI)
                    ctx.fill()
                } else {
                    ctx.save();
                    ctx.translate(32 - 7.5, -(15 - 7.5));
                    ctx.rotate((Math.PI / 180) * (0 + (-Math.abs(-160 * this.punchper + 80) + 80)))
                    ctx.beginPath()
                    ctx.fillStyle = 'black'
                    ctx.arc(7.5, -7.5, 7.5, 0, 2 * Math.PI)
                    ctx.fill()
                    ctx.beginPath()
                    ctx.fillStyle = '#7F7F7F'
                    ctx.arc(7.5, -7.5, 7.5 - 2, 0, 2 * Math.PI)
                    ctx.fill()
                    ctx.restore();
                }
            } else {
                if(/Axe|Pickaxe|Sword|Hammer/.test(this.mainHand)){
                    if(/Axe/.test(this.mainHand)){
                        let img = this.mainHand.toLowerCase().replace(/\s/, '')
                        ctx.save()
                        ctx.translate(32 - 7.5 + 5, 0)
                        if(this.hitting) ctx.rotate((Math.PI / 180) * (360 - (-Math.abs(-120 * this.per + 60) + 60)))
                        ctx.save()
                        ctx.translate(-2.5 + 75/2 - 32 - 7.5 + 10, -30 + 75/2)
                        ctx.rotate((Math.PI / 180) * 180)
                        ctx.drawImage(Img[img], 0 - 75/2, 0 - 75/2, 75, 75)
                        ctx.restore()
                        ctx.drawImage(Img.hand, 0, 15 - 7.5 - 5, 15, 15)
                        ctx.drawImage(Img.hand, 0, 15 - 2 - 7.5 - 30, 15, 15)
                        ctx.restore()
                    }else if(/Pickaxe/.test(this.mainHand)){
                        let img = this.mainHand.toLowerCase().replace(/\s/, '')
                        ctx.save()
                        ctx.translate(32 - 7.5 + 5, 0)
                        
                        if(this.hitting) ctx.rotate((Math.PI / 180) * (360 - (-Math.abs(-120 * this.per + 60) + 60)))
                        ctx.save()
                        ctx.translate(-2.5 + 75/2 - 32 - 7.5 + 10, -30 + 75/2)
                        ctx.rotate((Math.PI / 180) * 180)
                        ctx.drawImage(Img[img], 0 - 75/2, 0 - 75/2, 75, 75)
                        ctx.restore()
                        ctx.drawImage(Img.hand, 0, 15 - 7.5 - 5, 15, 15)
                        ctx.drawImage(Img.hand, 0, 15 - 2 - 7.5 - 30, 15, 15)
                        ctx.restore()
                    }else if(/Sword/.test(this.mainHand)){
                        let img = this.mainHand.toLowerCase().replace(/\s/, '')
                        ctx.save()
                        ctx.translate(32 - 7.5 + 5, 0)
                        ctx.strokeStyle = 'black'
                        ctx.lineWidth = '20px'
                        ctx.drawImage(Img.hand, -15, 15 - 7.5 - 5 + 25, 15, 15)
                        if(this.hitting) ctx.rotate((Math.PI / 180) * (360 - (-Math.abs(-120 * this.per + 60) + 60)))
                        ctx.save()
                        ctx.translate(-2.5 + 75/2 - 32 - 7.5 + 10, -30 + 75/2)
                        ctx.rotate((Math.PI / 180) * 180)
                        ctx.drawImage(Img[img], 0 - 75/2, 0 - 75/2, 75, 75)
                        ctx.restore()
                    
                        ctx.drawImage(Img.hand, 0, 15 - 2 - 7.5 - 30, 15, 15)
                        ctx.restore()
                    }else if(/Hammer/.test(this.mainHand)){
                        let img = this.mainHand.toLowerCase().replace(/\s/, '')
                        ctx.save()
                        ctx.translate(32 - 7.5 + 5, 0)
                        if(this.hitting) ctx.rotate((Math.PI / 180) * (360 - (-Math.abs(-120 * this.per + 60) + 60)))
                        ctx.save()
                        ctx.translate(-2.5 + 75/2 - 32 - 7.5 + 10, -30 + 75/2)
                        ctx.rotate((Math.PI / 180) * 180)
                        ctx.drawImage(Img[img], 0 - 75/2, 0 - 75/2, 75, 75)
                        ctx.restore()
                        ctx.drawImage(Img.hand, 0, 15 - 7.5 - 5, 15, 15)
                        ctx.drawImage(Img.hand, 0, 15 - 2 - 7.5 - 30, 15, 15)
                        ctx.restore()
                    }
                }
                if(/Wall|Door|Floor|Crafting Table|Chest/.test(this.mainHand)){
                    let img = this.mainHand.toLowerCase().replace(/\s/, '')
                    ctx.drawImage(Img.hand, 32 - 7.5, -15 - 7.5, 15, 15)
                    ctx.save()
                    ctx.translate(32 - 7.5 + 5, 0)
                    ctx.drawImage(Img.hand, -15, 15 - 7.5 - 5 + 25, 15, 15)
                    ctx.restore()
                }
                if(this.mainHand == 'carrot'){
                    ctx.save();
                    ctx.translate(32, 15);
                    let r
                    if(this.per) r = (Math.PI / 180) * (360 - (-Math.abs(-160 * this.per + 80) + 80))
                    else r = 0
                    if(r < 180) r += 180
                    else r -= 180
                    ctx.rotate(r)
                    ctx.beginPath()
                    ctx.fillStyle = 'black'
                    ctx.arc(0, 0, 7.5, 0, 2 * Math.PI)
                    ctx.fill()
                    ctx.beginPath()
                    ctx.fillStyle = '#7F7F7F'
                    ctx.arc(0, 0, 7.5 - 2, 0, 2 * Math.PI) 
                    ctx.fill()
                    ctx.drawImage(Img.carrot, 0 - 15, 0 - 15, 30, 30)
                    ctx.restore()
                    
                    ctx.beginPath()
                    ctx.fillStyle = 'black'
                    ctx.arc(32, -15, 7.5, 0, 2 * Math.PI)
                    ctx.fill()
                    ctx.beginPath()
                    ctx.fillStyle = '#7F7F7F'
                    ctx.arc(32, -15, 7.5 - 2, 0, 2 * Math.PI)
                    ctx.fill()
                }
                //ctx.drawImage(Img[this.mainHand], 32 - 7.5, 15 - 7.5, 15, 15)
            }
            ctx.restore()
            ctx.beginPath()
            ctx.fillStyle = '#000010'
            ctx.arc(currx, curry, this.rad, 0, 2 * Math.PI)
            ctx.fill()
            ctx.beginPath()
            ctx.fillStyle = '#C3C3C3'
            ctx.arc(currx, curry, this.rad - 2, 0, 2 * Math.PI)
            ctx.fill()
            ctx.translate(currx, curry)
            ctx.rotate((Math.PI / 180) * this.angle)
            ctx.fillStyle = 'black'
            ctx.beginPath()
            ctx.arc(0 + 9 * this.rad/28, 0 + 8 * this.rad/28, 6 * this.rad/28, 0, 2*Math.PI);
            ctx.arc(0 + 9 * this.rad/28, 0 - 8 * this.rad/28, 6 * this.rad/28, 0, 2*Math.PI);
            ctx.fill()
            ctx.fillStyle = 'white'
            ctx.beginPath()
            ctx.arc(0 + 6.5 * this.rad/28, 0 + 7 * this.rad/28, 2.5 * this.rad/28, 0, 2*Math.PI);
            ctx.arc(0 + 6.5 * this.rad/28, 0 - 7 * this.rad/28, 2.5 * this.rad/28, 0, 2*Math.PI);
            ctx.fill()
            ctx.restore();
            ctx.restore();
        }
    }
    let p = new miniPlayer({
        usr:'',
        x:450,
        y:450,
        lhit:false,
        rhit:false,
        rad:75,
        angle:315
    })
    p.punchper = 0
    p.lhit = true
    //p.drawPerf()
    let href = document.createElement('a')
    href.href = canvas.toDataURL('image/png')
    href.style.display = 'none'
    href.download = 'favicon.png'
    document.body.appendChild(href)
    //href.click()
    var video = document.getElementById('video');
    let supportedType
    let types = [
        "video/webm",
        'video/webm,codecs=vp9',
        'video/vp8',
        "video/webm\;codecs=vp8",
        "video/webm\;codecs=daala",
        "video/webm\;codecs=h264",
        "video/mpeg"
    ];
    let supportedTypes = types.filter(t => MediaRecorder.isTypeSupported)
    var mimeCodec = supportedTypes[4];
    console.log(supportedTypes)
    let stream = canvas.captureStream()
    //video.srcObject = stream
    let recorder = new MediaRecorder(stream)
    let chunks = []
    recorder.addEventListener('dataavailable', e => {
        a.href = URL.createObjectURL(new Blob([e.data]))
        //a.click()
    })
    recorder.start()
    let a = document.createElement('a')
    //a.href = URL.createObjectURL('ee')
    a.download = 'favicon.mp4'
    setTimeout(() => recorder.stop(), 1000)
    let drawPolygon = (sides,  size, x, y, angle, color) => {
        ctx.beginPath();
        ctx.moveTo (x +  size * Math.cos(0), y +  size *  Math.sin(0));          
        
        for (var i = 1; i <= sides;i += 1) {
            ctx.lineTo (x + size * Math.cos(i * 2 *  Math.PI / sides), y + size * Math.sin(i * 2 * Math.PI / sides));
        }
        
        ctx.fillStyle = color;
        ctx.lineWidth = 1;
        ctx.fill();
        ctx.restore()
    }
    let drawConcave = (sides,  size, x, y, angle, color) => {
        ctx.beginPath();
        ctx.moveTo (x +  size * Math.cos(0), y +  size *  Math.sin(0));          
        
        for (var i = 1; i <= sides;i += 1) {
            ctx.lineTo (x + size * Math.cos(i * 2 * angle *  Math.PI / sides), y + size * Math.sin(i * 2 * angle * Math.PI / sides));
        }
        
        ctx.fillStyle = color;
        ctx.lineWidth = 1;
        ctx.fill();
        ctx.restore()
    }
    let pixels = [1080]
    pixels.forEach(pixel => {
        ctx.clearRect(0, 0, canvas.width, canvas.height)
        pixel += 'px'
        pixelNum = parseInt(pixel)
        console.log(pixelNum)
        /** 
        * @type {HTMLCanvasElement}
        */
        canvas.style.width = pixelNum + 'px'
        canvas.style.height = pixelNum + 'px'
        canvas.width = parseInt(pixel)
        canvas.height = parseInt(pixel)
        45 /(Math.PI/180)
        drawConcave(8, pixelNum/2, pixelNum/2, pixelNum/2, 45, "#50c878")
        drawPolygon(13, pixelNum * 175/900, pixelNum/2, pixelNum/2, 0, "#b06831")
        let ctxdl = document.createElement('a')
        a.href = canvas.toDataURL('image/png')
        a.download = 'tree-' + pixelNum +'.png'
        a.click()
    })
    
    /**
    for(let i = 0; i < len; i++) {
        // extract alpha channel from a pixel
        let px = data32[i] & 0xff000000;                   // little-endian: ABGR
        console.log(data32[i])
        // any non-transparency? ie. alpha > 0
        if (px) {
        data32[i] = px | 0xffffff;    // set this pixel to white, keep alpha level
        }
    }
    **/
    // done
    //ctx.putImageData(imageData, 0, 0);
    setTimeout(() => {
        //recorder.stop()
    }, 6000)
    //createImage('ironsword', 'png')
    //createImage('ironpickaxe', 'png')
</script>
</body>{}